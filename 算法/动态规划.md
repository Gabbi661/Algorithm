**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。
首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要熟练掌握递归思维，只有列出**正确的「状态转移方程」**，才能正确地穷举。而且，你需要判断算法问题是否**具备「最优子结构」**，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题**存在「重叠子问题」**，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

以上提到的==重叠子问题、最优子结构、状态转移方程==就是动态规划三要素。
在实际的算法问题中，写出状态转移方程是最困难的。
这是我在网上找到的一个总结的思维框架，能辅助思考状态转移方程：
**明确「状态」-> 明确「选择」 -> 定义 `dp` 数组/函数的含义**。
按上面的套路走，最后的解法代码就会是如下的框架：
```java
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

> [!Tip] Tip
> 但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
斐波那契数列的数学形式就是递归的，写成代码就是这样：
```java
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```
这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：
![](https://labuladong.online/algo/images/dynamic-programming/1.jpg)

这个递归树怎么理解？就是说想要计算原问题 `f(20)`，我就得先计算出子问题 `f(19)` 和 `f(18)`，然后要计算 `f(19)`，我就要先算出子问题 `f(18)` 和 `f(17)`，以此类推。最后遇到 `f(1)` 或者 `f(2)` 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。
**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间**。
首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。
然后计算解决一个子问题的时间，在本算法中，没有循环，只有 `f(n - 1) + f(n - 2)` 一个加法操作，时间为 O(1)。
所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。
观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 `f(18)` 被计算了两次，而且你可以看到，以 `f(18)` 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 `f(18)` 这一个节点被重复计算，所以这个算法及其低效。
这就是动态规划问题的第一个性质：**重叠子问题**。

接下来使用备忘录方法解决这个问题。

#### 自顶向下
```java
public int fib(int n) {  
       int [] memo = new int[n+1];  
       return fib2(n,memo);  
}  

  // 带着备忘录进行递归
public int fib2(int n,int[] memo) {  
    if(n==0||n==1){  
     return n;  
    }  
    //已经计算过了，不用再计算了
    if(memo[n]!=0){  
        return memo[n];  
    }  
    memo[n]=fib2(n-1,memo)+fib2(n-2,memo);  
    
    return memo[n];  
}
```

实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

![](https://labuladong.online/algo/images/dynamic-programming/3.jpg)

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间**。

子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 `f(1)`, `f(2)`, `f(3)` ... `f(20)`，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)。

#### 自底向上
从树的底层元素逐渐往上递推

```java
int fib(int N) {
    if (N == 0) return 0;
    int[] dp = new int[N + 1];
    // base case
    dp[0] = 0; dp[1] = 1;
    // 状态转移
    for (int i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[N];
}
```

根据斐波那契数列的状态转移方程，当前状态 `n` 只和之前的 `n-1, n-2` 两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。

所以，可以进一步优化，把空间复杂度降为 O(1)。这也就是我们最常见的计算斐波那契数的算法：
```java
int fib(int n) {
    if (n == 0 || n == 1) {
        // base case
        return n;
    }
    // 分别代表 dp[i - 1] 和 dp[i - 2]
    int dp_i_1 = 1, dp_i_2 = 0;
    for (int i = 2; i <= n; i++) {
        // dp[i] = dp[i - 1] + dp[i - 2];
        int dp_i = dp_i_1 + dp_i_2;
        // 滚动更新
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i_1;
}
```

这一般是动态规划问题的最后一步优化，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度。

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
你可以认为每种硬币的数量是无限的。
**示例 1：**
**输入：**coins = `[1, 2, 5]`, amount = `11`
**输出：**`3` 
**解释：**11 = 5 + 5 + 1
**示例 2：**
**输入：**coins = `[2]`, amount = `3`
**输出：**-1
**示例 3：**
**输入：**coins = [1], amount = 0
**输出：**0

---
你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。
首先，这个问题是动态规划问题，因为它具有「最优子结构」的。**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？
一个直观的例子来解释：
比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。
得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。
但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。
这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。
回到凑零钱问题，为什么说它符合最优子结构呢？假设你有面值为 `1, 2, 5` 的硬币，你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10, 9, 6` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 `1, 2, 5` 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

#### 暴力解法
这个时间复杂度是指数级别的，一旦数量一多，运行测试用例就会超出时间限制。
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // 题目要求的最终结果是 dp(amount)
        return dp(coins, amount);
    }

    // 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
    int dp(int[] coins, int amount) {
        // base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }

        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
```

#### 备忘录解法
```java
class Solution {
    int[] memo;

    public int coinChange(int[] coins, int amount) {
        memo = new int[amount + 1];
        // 备忘录初始化为一个不会被取到的特殊值，代表还未被计算
        Arrays.fill(memo, -666);

        return dp(coins, amount);
    }

    int dp(int[] coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // 查备忘录，防止重复计算
        if (memo[amount] != -666)
            return memo[amount];

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
        // 把计算结果存入备忘录
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
}

```
很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 `n`，即子问题数目为 O(n)O(n)。处理一个子问题的时间不变，仍是 O(k)O(k)，所以总的时间复杂度是 O(kn)O(kn)。

#### 迭代解法

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        // 数组大小为 amount + 1，初始值也为 amount + 1
        Arrays.fill(dp, amount + 1);

        // base case
        dp[0] = 0;
        // 外层 for 循环在遍历所有状态的所有取值
        for (int i = 0; i < dp.length; i++) {
            // 内层 for 循环在求所有选择的最小值
            for (int coin : coins) {
                // 子问题无解，跳过
                if (i - coin < 0) {
                    continue;
                }
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
}
```

为啥 `dp` 数组中的值都初始化为 `amount + 1` 呢，因为凑成 `amount` 金额的硬币数最多只可能等于 `amount`（全用 1 元面值的硬币），所以初始化为 `amount + 1` 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int 型的最大值 `Integer.MAX_VALUE` 呢？因为后面有 `dp[i - coin] + 1`，这就会导致整型溢出。

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
**示例 1：**

**输入：**n = 2
**输出：**2
**解释：**有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

**示例 2：**

**输入：**n = 3
**输出：**3
**解释：**有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
---
我的初步想法：
这个和零钱那道题有点像，n层楼梯的爬法等于n-1层的爬法加n-2层的爬法
我的代码一开始大致是对的，但是运行多个用例后却惨遇超时，原因是：
1. **memo 数组每次递归都会重新创建**
• 在 climbWays(n) 内部声明 memo，这意味着每次调用 climbWays(n-1) 或 climbWays(n-2) 时，memo 都会被重新初始化，导致记忆化存储 **失效**。
• 记忆化存储的作用是避免重复计算，但你的实现方式使得它**每次都重新计算相同的值**。
解决方案是：
```java
class Solution {

int [] memo;//将备忘录放在方法外部进行声明

public int climbStairs(int n) {

memo = new int[n+1];//在主函数中规定备忘录数组的大小

return climbWays(n);

  

}

public int climbWays(int n) {

if(n==0||n<0){

return 0;

}

if(n==1){

return 1;

}

if (n==2){

return 2;

}

if(memo[n]!=0){

return memo[n];

}

memo[n]=climbWays(n-1)+climbWays(n-2);

return memo[n];

}

}
```

### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

给定一个非负整数 _`numRows`，_生成「杨辉三角」的前 _`numRows`_ 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

**示例 1:**

**输入:** numRows = 5
**输出:** [ [1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]  ]

**示例 2:**

**输入:** numRows = 1
**输出:** [ [1] ]

---
这道题其实比较好做，但是我一开始把它想复杂了，相比其他题这道题的实现逻辑很好理解，只要注意一些小细节（循环时的界限）就可以了。
```java
public List<List<Integer>> generate(int numRows) {

List<List<Integer>> result = new ArrayList<>();

for (int i = 0; i < numRows; i++) {
List<Integer> temp = new ArrayList<>();
for(int j = 0; j < i+1; j++){
if(j==0||j==i){
temp.add(1);
}else {

temp.add(result.get(i-1).get(j-1)+result.get(i-1).get(j));
}
}
result.add(temp);
}
return result;

}
```

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**
**输入：**[1,2,3,1]
**输出：**4
**解释：**偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
**示例 2：**
**输入：**[2,7,9,3,1]
**输出：**12
**解释：**偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

---
这道题采用的还是典型的动态规划思想，这么money数组里存储的是打劫到n家能挣到的最多的钱。
如果你想打劫第n家，那么第n-1家肯定不能打劫，所以要衡量一下，是打劫到底n-2家加上第n家的钱多，还是打劫到第n-1家的钱多。
之前的都是前一项，关系都是紧挨着的，现在是需要隔一项。要注意变通。

```java
public int rob(int[] nums) {

int [] money = new int[nums.length];

if(nums ==null){

return 0;

}

if (nums.length == 1){

return nums[0];

}

if (nums.length == 2){

return Math.max(nums[0],nums[1]);

}

money[0] = nums[0];

money[1] = Math.max(nums[0],nums[1]);

for (int i = 2; i < nums.length; i++) {

money[i] = Math.max(money[i-2]+nums[i],money[i-1]);

}

return money[money.length-1];

}

```

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

给你一个整数 `n` ，返回 _和为 `n` 的完全平方数的最少数量_ 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

**输入：**n = `12`
**输出：**3 
**解释：**`12 = 4 + 4 + 4`

**示例 2：**

**输入：**n = `13`
**输出：**2
**解释：**`13 = 4 + 9`

---
我一开始代码的问题：
1. **初始化问题**
• memo[i] 在计算时，默认值是 0，但我们需要设置一个较大的初值（例如 Integer.MAX_VALUE），否则 Math.min() 可能会导致错误。
2. **状态转移方程错误**
• 你的 Math.min(memo[i-(sqrtN*sqrtN)]+1, memo[i-1]+1); 只考虑了最大的完全平方数 sqrtN * sqrtN，但实际上 **应该遍历所有小于 i 的完全平方数**，才能找到最优解。

正确代码：
```java
public int numSquares(int n) {
    int[] dp = new int[n + 1];
    
    // 初始化 dp 数组，最大情况就是 n 个 1 相加
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0; // 0 需要 0 个完全平方数
    dp[1] = 1; // 1 只能由 1 组成
    
    // 遍历 1 到 n
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j * j <= i; j++) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    
    return dp[n];
}
```

### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1:**

**输入:** nums = [2,3,-2,4]
**输出:** `6`
**解释:** 子数组 [2,3] 有最大乘积 6。

**示例 2:**

**输入:** nums = [-2,0,-1]
**输出:** 0
**解释:** 结果不能为 2, 因为 [-2,-1] 不是子数组。

---
知道这是动态规划，也知道要状态转移，但是没有具体的思路，不知道dp[ i ] 的状态由谁转移来。
再加上这个是连续的数组，感觉和上一道题不连续的子数组解决方法不同。
这道题有负数存在，负数可能会让最小变最大，需要谨慎考虑，我被难住就是因为不知道负数该怎么处理。
而这道题的正确解法需要维护 **最大乘积 maxDP 和最小乘积 minDP**。
一开始我想的是两个数组，Max和Min，因为循环每次会保存最大乘积的值，所以数组就会浪费内存，直接设置两个整数值即可。
状态转移思路：
1. **如果 nums[i] 是正数**，那么：
• maxDP[i] = max(nums[i], maxDP[i-1] * nums[i])，即：要么选择自己，要么乘上之前的最大值。
• minDP[i] = min(nums[i], minDP[i-1] * nums[i])，即：要么选择自己，要么乘上之前的最小值（负数）。
2. **如果 nums[i] 是负数**，那么：
• maxDP[i] = max(nums[i], minDP[i-1] * nums[i])（最小值乘负数可能变最大）。
• minDP[i] = min(nums[i], maxDP[i-1] * nums[i])（最大值乘负数可能变最小）。

在实际写代码时，不需要分正数一种情况，负数一种情况，直接把它们合起来用`Math.max(dpMin*nums[i],dpMax*nums[i])`一比较即可

之所以要比较 **三个值**，是因为：
```java
dpMax=Math.max(nums[i], Math.max(dpMin*nums[i],dpMax*nums[i]));
dpMin=Math.min(nums[i], Math.min(tempMax*nums[i],dpMin*nums[i]));
```
1. nums[i] 可能是 **新的起点**，如果前面的积变小（甚至归零），nums[i] 可能比 dpMax * nums[i] 和 dpMin * nums[i] 都大。
2. dpMax * nums[i] 可能继续扩展最大乘积（如果 nums[i] 是正数）。
3. dpMin * nums[i] 可能成为新的最大乘积（如果 nums[i] 是负数，之前的最小乘积翻转）。
完整代码：
```java
public int maxProduct(int[] nums) {

if (nums.length == 0){

return 0;

}

if (nums.length == 1){

return nums[0];

}

int dpMax ;

int dpMin ;

dpMax = nums[0];

dpMin = nums[0];

int result = nums[0];//这个初始值一定要设置对

for (int i = 1; i < nums.length; i++) {

int tempMax=dpMax;//这里要注意，因为dpMax的值是最先变的，所以要将一开始的值存下

dpMax=Math.max(nums[i], Math.max(dpMin*nums[i],dpMax*nums[i]));

dpMin=Math.min(nums[i], Math.min(tempMax*nums[i],dpMin*nums[i]));

result = Math.max(result,dpMax);

}

return result;

}
```

### 通过或运算进行状态转移
#### [139. 单词拆分](https://leetcode.cn/problems/word-break/)


给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。
**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
**示例 1：**
**输入:** s = "leetcode", wordDict = ["leet", "code"]
**输出:** true
**解释:** 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
**示例 2：**
**输入:** s = "applepenapple", wordDict = ["apple", "pen"]
**输出:** true
**解释:** 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
**示例 3：**
**输入:** s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
**输出:** false

----
这道题一开始我想的是从前往后，一个字母一个字母地比对，但这样做效率会很低，尤其是当字符串很长时。最优的做法是使用 **动态规划（DP）**。

正确代码：
```java
public boolean wordBreak(String s, List<String> wordDict) {

int n = s.length();

boolean[] dp = new boolean[n + 1];

dp[0] = true;

for (int i = 0; i <= n; i++) {

for (String word : wordDict) {

int len = word.length();

if (i >= len && s.substring(i - len, i).equals(word)) {

dp[i] = dp[i - len] || dp[i];
}
}
}
return dp[n];
}
```

有几个要点：
1. dp[0]等于true，因为最后判断dp数组内的值是采用或运算，一旦0-i的字符串等于字典中的某个词，通过或运算能让dp[i]等于true。
2. dp[i] = dp[i - len] || dp[i]; 一开始我对这句抱有疑问，后来我明白了，因为一开始数组中除了0的位置其他都是false，所以如果他前面的i-length都为false，那dp[i]这个位置一定也是false。


#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

**输入：**nums = [1,5,11,5]
**输出：**true
**解释：**数组可以分割成 [1, 5, 5] 和 [11] 。

**示例 2：**

**输入：**nums = [1,2,3,5]
**输出：**false
**解释：**数组不能分割成两个元素和相等的子集。

---
```java
public boolean canPartition(int[] nums) {

int sum = 0;

for (int num : nums) {

sum += num;

}

  

// 如果总和是奇数，不能分成两个相等的子集

if (sum % 2 != 0) {

return false;

}

  

int target = sum / 2;

boolean[] dp = new boolean[target + 1];

dp[0] = true; // 目标和为0时，空集是一个可行解

  

// 动态规划更新dp数组

for (int num : nums) {

// 从后往前遍历，避免重复计算

for (int i = target; i >= num; i--) {

dp[i] = dp[i] || dp[i - num];

}

}

  

return dp[target];

}

```

这道题和上一道题状态转移有点像，上一道题是比对字符串是否吻合，这道题是比对数的和是否相同

给定一个数组 nums，我们想要判断是否能将其分成两个和相等的子集。可以通过以下步骤进行求解：
1. 计算整个数组的和 S。
2. 如果 S 是奇数，则无法平分为两个子集，因为两个子集的和必须是整数，因此返回 false。
3. 如果 S 是偶数，设 target = S / 2。问题就转化为：是否存在一个子集，其和为 target。

**动态规划实现：**
1. 使用一个布尔数组 dp，其中 dp[i] 表示是否可以从 nums 中选择一些元素，使得它们的和为 i。
2. 初始化 dp[0] = true，因为总是可以通过选择空集得到和为 0。
3. 对于每个 num，更新 dp 数组，dp[i] = dp[i] || dp[i - num]，表示如果可以通过前面的数字组合得到和为 i - num，那么就可以得到和为 i。

#### [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

**输入：**s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
**输出：**true

**示例 2：**

**输入：**s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
**输出：**false

**示例 3：**

**输入：**s1 = "", s2 = "", s3 = ""
**输出：**true

-------------
dp\[i][j] 表能否用 s1 的前 i 个字符 和 s2 的前 j 个字符 **交错组成** s3 的前 i + j 个字符
当前 dp\[ i]\[j] 有两个**可能的来源**：
- 从 s1 的字符来：dp\[i - 1][j]
- 或者从 s2 的字符来：dp\[i][j - 1]

```java
public boolean isInterleave(String s1, String s2, String s3) {  
    int m = s1.length();  
    int n = s2.length();  
    if (m + n != s3.length()) {  
        return false;  
    }  
    boolean[][] dp = new boolean[m + 1][n + 1];  
    dp[0][0] = true;  
    for (int i = 0; i < m; i++) {  
        for (int j = 0; j < n; j++) {  
        //从s1拿一个字符
            if (i > 0 && s1.charAt(i - 1) == s3.charAt(j + i - 1)) {  
                dp[i][j] = dp[i][j] || dp[i - 1][j];  
            }  
        //从s2拿一个字符
            if (j > 0 && s2.charAt(j - 1) == s3.charAt(i + j - 1)) {  
                dp[i][j] = dp[i][j] || dp[i][j - 1];  
            }  
        }  
    }  
    return dp[m][n];  
}

```
如果我之前只用了 s1 的前 i - 1 个字符和 s2 的前 j 个字符，能拼出 s3 的前 i + j - 1 个字符（即 dp\[i-1][j] = true），并且下一个字符 s1[i-1] 正好等于 s3[i + j - 1]，
那我就可以从那个状态走过来，dp\[i][j] = true。


### 动态规划之最小路径和
一般来说，让在二维矩阵中求最优化问题（最大值或最小值），肯定需要递归➕备忘录，也就是动态规划技巧。

#### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)
给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
**说明：**每次只能向下或者向右移动一步。
**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

**输入：grid = [ [1,3,1],[1,5,1],[4,2,1] ]
**输出：**7
**解释：**因为路径 1→3→1→1→1 的总和最小。

**示例 2：**

**输入：grid = [ [1,2,3],[4,5,6] ]
**输出：**12

----
![[截屏2025-03-13 16.22.12.png]]


我们想计算从起点 D 到达 B 的最⼩路径和，那你说怎么才能到达 B 呢？
题⽬说了只能向右或者向下⾛，所以只有从 A 或者 C ⾛到 B。
那么算法怎么知道从 A ⾛到 B 才能使路径和最⼩，⽽不是从 C ⾛到 B 呢？
难道是因为位置 A 的元素⼤⼩是 1，位置 C 的元素是 2，1 ⼩于 2，所以⼀定要从 A ⾛到 B 才能使路径和最⼩吗？
其实不是的，真正的原因是，从 D ⾛到 A 的最⼩路径和是 6，⽽从 D ⾛到 C 的最⼩路径和是 8，6 ⼩于 8，
所以⼀定要从 A ⾛到 B 才能使路径和最⼩。
换句话说，我们把「从 D ⾛到 B 的最⼩路径和」这个问题转化成了「从 D ⾛到 A 的最⼩路径和」和 「从 D⾛到 C 的最⼩路径和」这两个问题。
这就是这道题状态转移的思想。

一开始采用的是迭代的方法，但是测试用例的时候超时了，所以改为这种备忘录的方法。
```java
int [][] memo2 ;
public int minPathSum(int[][] grid) {
int m = grid.length;
int n = grid[0].length;
memo2 = new int[m][n];
for (int[] row : memo2)
Arrays.fill(row, -1);//因为这个矩阵中全是非负数，所以他们的和也都是非负数，一开始设置成-1可以体现出备忘录中的值是否是后添加上的
return minPathSumdp(grid,m-1,n-1);
}

public int minPathSumdp(int[][] grid,int i,int j) {
if(i==0 && j==0){
return grid[0][0] ;
}

if(i<0 ||j<0){
return Integer.MAX_VALUE;
}

if(memo2[i][j] !=-1){
return memo2[i][j];

}


memo2[i][j] = Math.min(minPathSumdp(grid,i-1,j),minPathSumdp(grid,i,j-1))+grid[i][j];

return memo2[i][j];

}

```


### [887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)

给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？

 

**示例 1：**

**输入：**k = 1, n = 2
**输出：**2
**解释：**
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 

**示例 2：**

**输入：**k = 2, n = 6
**输出：**3

**示例 3：**

**输入：**k = 3, n = 14
**输出：**4

---
观感是这道题非常难😭
不过扔鸡蛋问题是一个很经典的算法问题。
思路：
- **确定状态 (`dp[i][j]` 的含义)**
我们定义 `dp[k][n]` 表示：
• **k 个鸡蛋**
• **n 层楼**
• **在最坏情况下，找到 f 所需的最小尝试次数**
换句话说，`dp[k][n]` 就是**用 k 个鸡蛋，测 n 层楼，确定 f 需要的最少次数**。
- 创建状态转移方程
如果我们从第 x 层扔鸡蛋，会有两种情况：
1. **鸡蛋碎了**（f ≤ x）：此时 f 必然在 x-1 层以下，我们的问题变成 **k-1 个鸡蛋、x-1 层楼**（ `dp [k-1][x-1]`）。
2. **鸡蛋没碎**（f > x）：此时 f 必然在 n-x 层之上，我们的问题变成 **k 个鸡蛋、n-x 层楼**（`dp[k][n-x]`）。
这里的k没变是因为鸡蛋没碎，数量没有发生变化。
由于我们要考虑**最坏情况下的最小尝试次数**，所以我们取 **碎了和没碎两种情况中的最大值**（保证最坏情况最少），再加上当前这次尝试：
![[截屏2025-03-13 17.07.59.png]]
这个递推式的意义是：
• 1 + 代表 **当前扔了一次**。
• `max(dp[k-1][x-1], dp[k][n-x]) `代表 **在所有可能的 x 楼层中，我们要取最坏情况下的最优解**。
• min 代表 **我们希望 x 选择得最优，使得最大值最小**。
- **确定边界条件**
1. **只有 1 个鸡蛋** (k = 1)：
• 只能一层一层试，最坏情况下要试 n 次，所以：
dp\[1]\[n] = n
2. **只有 1 层楼** (n = 1)：
• 只需要扔 1 次，所以：
dp\[k]\[1] = 1
3. **没有楼 (n = 0)**：
• 不需要扔，尝试次数为 0：
dp\[k]\[0] = 0

```java
public int superEggDrop(int k, int n) {

int[][] dp = new int[k + 1][n + 1];

// 边界情况：1 个鸡蛋时，最坏情况下需要 n 次尝试

for (int j = 1; j <= n; j++) {

dp[1][j] = j;

}

// 填表

for (int i = 2; i <= k; i++) {

for (int j = 1; j <= n; j++) {

dp[i][j] = Integer.MAX_VALUE;

for (int x = 1; x <= j; x++) {

// 碎了和没碎两种情况，取最坏情况的最优解

int worstCase = Math.max(dp[i - 1][x - 1], dp[i][j - x]) + 1;

dp[i][j] = Math.min(dp[i][j], worstCase);

}

}

}

return dp[k][n];

}

```
这里的 dp\[i]\[j] 需要遍历 x，导致**三层循环**，时间复杂度是 O(k * n²)，对于 n 比较大时会超时。

为什么是三重循环呢
对于**三个变量**：
• k（鸡蛋数）
• n（楼层数）
• x（选择的楼层）
在实现 dp\[k]\[n] 时，我们需要：
1. **遍历鸡蛋数 k**（从 1 到 k）
2. **遍历楼层数 n**（从 1 到 n）
3. **遍历所有可能的 x 选择**（从 1 到 n）
所以代码里要实现三层循环

因为上一种方法超时，于是采用二分法
注意到 dp\[k-1\]\[x-1\] **随着 x 变大单调递增**，dp\[k]\[n-x] **随着 x 变大单调递减**，所以 max(dp\[k-1]\[x-1], dp\[k]\[n-x]) 有 **单峰性**，可以**用二分查找找到最优的 x**

```java
public int superEggDrop(int k, int n) {
    int[][] dp = new int[k + 1][n + 1];

    // 初始化边界条件：只有 1 个鸡蛋时，最坏情况下要从 1 层开始逐层试
    for (int j = 1; j <= n; j++) {
        dp[1][j] = j;
    }

    for (int i = 2; i <= k; i++) {  // 遍历鸡蛋数
        for (int j = 1; j <= n; j++) {  // 遍历楼层数
            int left = 1, right = j;
            while (left + 1 < right) {  // 二分查找最优的 `x`
                int mid = left + (right - left) / 2;
                int breakCase = dp[i - 1][mid - 1];  // 鸡蛋碎的情况
                int noBreakCase = dp[i][j - mid];    // 鸡蛋没碎的情况
                
                if (breakCase > noBreakCase) {
                    right = mid;  // `mid` 太高了，鸡蛋碎的情况更糟糕，应该往下试
                } else {
                    left = mid;  // `mid` 太低了，鸡蛋没碎的情况更糟糕，应该往上试
                }
            }

            // 选最优 `left` 或 `right`
            dp[i][j] = 1 + Math.min(
                Math.max(dp[i - 1][left - 1], dp[i][j - left]),
                Math.max(dp[i - 1][right - 1], dp[i][j - right])
            );
        }
    }

    return dp[k][n];
}

```

二分查找的核心逻辑：
• **当 breakCase > noBreakCase 时，说明 mid 选得太高了，需要降低 right。**
• **当 breakCase < noBreakCase 时，说明 mid 选得太低了，需要增加 left。**
• **最终 left 和 right 会收敛到相邻的两个数，即 left + 1 == right。**

**为什么 left 和 right 都可能是最优解？**
因为 dp\[i - 1]\[x - 1] 是递增的，而 dp\[i]\[j - x] 是递减的：
• left 对应的 max(dp\[i - 1]\[left - 1], dp\[i]\[j - left]) 可能更小。
• right 对应的 max(dp\[i - 1]\[right - 1], dp\[i]\[j - right]) 也可能更小。
所以，我们**必须计算这两个 x 的结果，并取更小的那个**，确保 dp\[i]\[j] 取到最优解。

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)
一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

**输入：**m = 3, n = 7
**输出：**28

**示例 2：**

**输入：**m = 3, n = 2
**输出：**3
**解释：**
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

**示例 3：**

**输入：**m = 7, n = 3
**输出：**28

**示例 4：**

**输入：**m = 3, n = 3
**输出：**6

---
初步状态转移分析：
到达右下角的路径的方法等于到达它上方或者左边那个方块的最小值➕1

这道题比价好做，就是较易理解的动态规划问题


### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 109`。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

**输入：**obstacleGrid = [ [0,0,0],[0,1,0],[0,0,0]]
**输出：**2
**解释：**3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 `2` 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

**输入：**obstacleGrid = [ [0,1],[0,0]]
**输出：**1

--------
这道题与上一道题不同路径的解法差不多，关键的是对障碍物的处理，需要把有障碍物的那一点，可到达的路径数设置为0。初始化的时候要注意把障碍物和障碍物后面的点的可达路径数都初始化为0。
```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {  
    int m = obstacleGrid.length;  
    int n = obstacleGrid[0].length;  
    int[][] dp = new int[m][n];  
    boolean hasObstacle = false;  
    dp[0][0] = 1;  
    for (int i = 0; i < m; i++) {  
        if (obstacleGrid[i][0] == 1) {  
            hasObstacle = true;  
        }  
        if (!hasObstacle) {  
            dp[i][0] = 1;  
        } else {  
            dp[i][0] = 0;  
        }  
  
    }  
    hasObstacle = false;  
    for (int j = 0; j < n; j++) {  
  
        if (obstacleGrid[0][j] == 1) {  
            hasObstacle = true;  
        }  
        if (!hasObstacle) {  
            dp[0][j] = 1;  
        } else {  
            dp[0][j] = 0;  
        }  
    }  
    for (int i = 1; i < m; i++) {  
        for (int j = 1; j < n; j++) {  
            if (obstacleGrid[i][j] == 1) {  
                dp[i][j] = 0;  
            } else {  
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  
            }  
  
        }  
    }  
    return dp[m - 1][n - 1];  
}

```


### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

**输入：**text1 = "abcde", text2 = "ace" 
**输出：**3  
**解释：**最长公共子序列是 "ace" ，它的长度为 3 。

**示例 2：**

**输入：**text1 = "abc", text2 = "abc"
**输出：**3
**解释：**最长公共子序列是 "abc" ，它的长度为 3 。

**示例 3：**

**输入：**text1 = "abc", text2 = "def"
**输出：**0
**解释：**两个字符串没有公共子序列，返回 0 。

---
```java
public int longestCommonSubsequence(String text1, String text2) {

int m = text1.length();

int n = text2.length();

int [][] dp = new int[m+1][n+1];

for (int i = 1; i <= m; i++) {

for (int j = 1; j <= n; j++) {

if (text1.charAt(i - 1) == text2.charAt(j - 1)) {

dp[i][j] = dp[i - 1][j - 1] + 1;

}else{

dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);

}

}

}

return dp[m][n];

}
```

int\[]\[] dp = new int\[m + 1]\[n + 1]; 这样定义数组的主要目的是:
1. **避免 -1 越界问题**：直接用 dp\[i-1]\[j-1]，不用担心 i=0 或 j=0 时 -1 访问。
2. **天然初始化**：dp\[0]\[j] 和 dp\[i]\[0] 默认是 0，省去了 if 判断。
3. **返回 dp\[m][n] 更直观**，避免 dp\[m-1]\[n-1] 这种偏移计算。


### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

 

**示例 1：**

**输入：**nums = [10,9,2,5,3,7,101,18]
**输出：**4
**解释：**最长递增子序列是 [2,3,7,101]，因此长度为 4 。

**示例 2：**

**输入：**nums = [0,1,0,3,2,3]
**输出：**4

**示例 3：**

**输入：**nums = [7,7,7,7,7,7,7]
**输出：**1

-------------
dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。
对每个 i，我们去看 0~i-1 中所有的 j，如果 nums[j] < nums[i]，说明我们可以把 nums[i] 接在 nums[j] 后面形成更长的子序列。
```java
public int lengthOfLIS(int[] nums) {  
    if (nums == null || nums.length == 0) {  
        return 0;  
    }  
    int[] dp = new int[nums.length];  
    Arrays.fill(dp, 1);  
    for (int i = 1; i < nums.length; i++) {  
        for (int j = 0; j < i; j++) {  
            if (nums[i] > nums[j]) {  
                dp[i] = Math.max(dp[i], dp[j] + 1);  
            }  
        }  
    }  
    int res = 0;  
    for (int m : dp) {  
        res = Math.max(res, m);  
    }  
    return res;  
}

```

### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

**输入：**matrix = [ ["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
**输出：**4

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

**输入：**matrix = [ ["0","1"],["1","0"]]
**输出：**1

**示例 3：**

**输入：**matrix = [ ["0"]]
**输出：**0

---------------
这道题是求正方形的最大面积，就可以转化为求出正方形的最大边长。
每个方块根据它的上，左，左上的方块进行状态转移。
二维数组 dp\[i][j]表示：
以 matrix\[i][j] 为 **右下角** 的最大正方形边长。

```java
public int maximalSquare(char[][] matrix) {  
    int[][] dp = new int[matrix.length][matrix[0].length];  
    int max = 0;  
    for (int i = 0; i < matrix.length; i++) {  
        for (int j = 0; j < matrix[0].length; j++) {  
            if (matrix[i][j] == '1') {  
                if (i == 0 || j == 0) {  
                    dp[i][j] = 1;  
                } else {  
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;  
                }  
            }  
            max = Math.max(max, dp[i][j]);  
        }  
    }  
    return max * max;  
}

```

### [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

**示例 1：**

**输入：**triangle = [ [2],[3,4],[6,5,7],[4,1,8,3]]
**输出：**11
**解释：**如下面简图所示：
   **2**
  **3** 4
 6 **5** 7
4 **1** 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

**示例 2：**

**输入：**triangle = [ [-10]]
**输出：**-10

-----------
这道题的思路不难想，重要的是怎么更改List中的值，使用set进行更改。
```java
public int minimumTotal(List<List<Integer>> triangle) {  
    for (int i = 1; i < triangle.size(); i++) {  
        for (int j = 0; j < triangle.get(i).size(); j++) {  
            int cur = triangle.get(i).get(j);  
            if (j == 0) {  
  
                triangle.get(i).set(j, cur + triangle.get(i - 1).get(j));  
            } else if (j == triangle.get(i).size() - 1) {  
                triangle.get(i).set(j, cur + triangle.get(i - 1).get(j - 1));  
            } else {  
                int min = Math.min(triangle.get(i - 1).get(j), triangle.get(i - 1).get(j - 1));  
                triangle.get(i).set(j, cur + min);  
            }  
        }  
    }  
    return Collections.min(triangle.get(triangle.size() - 1));  
}

```






### 背包问题
背包问题是一类经典的动态规划问题。
对于背包问题来说，它的状态有两个，`背包的容量`和`可以选择的物品`。
而对于每件物品，做出的选择就是`装进背包`和`不装进背包`。

状态有两个，则需要的dp数组也就是二维的。
dp\[i]\[w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最⼤价值是 dp\[i]\[w]。
比如dp\[3]\[5]=6，意为对于前3个物品，背包的容量为5，这种情况下可以装的最大价值为6。
根据这个定义，我们想求的最终答案就是 dp\[N]\[W]。base case 就是 dp\[0]\[..] = dp\[..]\[0] = 0，因为没有物品或者背包没有空间的时候，能装的最⼤价值就是 0。

#### 完全背包问题
在完全背包问题中，每个物体的数量是无限的。
##### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

**输入：**amount = 5, coins = [1, 2, 5]
**输出：**4
**解释：**有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

**示例 2：**

**输入：**amount = 3, coins = [2]
**输出：**0
**解释：**只用面额 2 的硬币不能凑成总金额 3 。

**示例 3：**

**输入：**amount = 10, coins = [10] 
**输出：**1

-----
这道题的状态有amount和硬币两种状态。
dp\[i]\[w]的意思应该为对于前i个硬币，金额为w，有多少种组成方式。
这道题最重要的是状态转移方程，这个不是要求组成金额的最多硬币是多少，所以不是用Math.max而是相加。
`dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]]`前半部分不选该硬币的部分很好理解，后半部分是选择该硬币，那么选之前钱数就是j-coins[i-1]。
```java
public int change(int amount, int[] coins) {  
  int [][] dp=new int[coins.length+1][amount+1];  
  for(int i=0;i<=coins.length;i++){  
      dp[i][0]=1;  
  }  
  
  for(int i=1;i<=coins.length;i++){  
      for(int j=0;j<=amount;j++){  
          if(j<coins[i-1]){  
              dp[i][j]=dp[i-1][j];  
          }else{  
              dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];  
  
          }  
      }  
  }  
  return dp[coins.length][amount];  
}
```

#### 子集背包问题
##### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

**输入：**nums = [1,5,11,5]
**输出：**true
**解释：**数组可以分割成 [1, 5, 5] 和 [11] 。

**示例 2：**

**输入：**nums = [1,2,3,5]
**输出：**false
**解释：**数组不能分割成两个元素和相等的子集。

----
这个题与上面的解决方法不同，是通过转换成背包问题来做的。
求出数组的和sum，如果有集合的和能等于sum的二分之一，那么证明剩下的集合之和也等于sum的二分之一，即存在两个子集之和相等。
```java
public boolean canPartition(int[] nums) {

int sum=0;

for(int num:nums){

sum+=num;

}

if(sum%2!=0){

return false;

}

int target=sum/2;

boolean[][] dp=new boolean[nums.length+1][target+1];


// 初始化：当 j = 0 时，任何集合都可以通过选 0 个元素来达到 0
for(int i=1;i<=nums.length;i++){

dp[i][0]=true;

}

for(int i=1;i<=nums.length;i++){

for(int j=1;j<=target;j++){

if(nums[i-1]>j){

dp[i][j]=dp[i-1][j];

}else{

dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]];

}

}

}


return dp[nums.length][target];
}

```


#### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

**输入：**nums = [1,2,3], target = 4
**输出：**7
**解释：**
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。

**示例 2：**

**输入：**nums = [9], target = 3
**输出：**0

-----
这道题重要的是==顺序不同的序列被视作不同的组合==
所以要先遍历target，再遍历nums。
这段描述可能不太好懂，看一个例子：
以 nums = [1, 2, 3], target = 4 为例

```java
dp[0] = 1
dp[1] = dp[0]（选1）= 1
dp[2] = dp[1]（选1） + dp[0]（选2）= 1 + 1 = 2
dp[3] = dp[2]（选1） + dp[1]（选2） + dp[0]（选3）= 2 + 1 + 1 = 4
dp[4] = dp[3]（选1） + dp[2]（选2） + dp[1]（选3）= 4 + 2 + 1 = 7

```

可以看到当需要和为3时，和为2选1 再加上和为1选2，就把那些排列不同的组合都选上了（1，2｜2，1）。

代码：
```java
public int combinationSum4(int[] nums, int target) {

int[] dp=new int[target+1];

dp[0]=1;

for(int i=1;i<=target;i++){

for(int num:nums){

if(i>=num){

dp[i]+=dp[i-num];

}

}

}

return dp[target];

}

```

## 股票交易问题
这类问题的本质就是使用动态规划。

### 一、穷举框架

这个问题每天都有三种选择：
- 买入
- 卖出
- 无操作
但问题是，并不是每天都可以任意选择这三种选择的，因为 `sell` 必须在 `buy` 之后，`buy` 必须在 `sell` 之后。那么 `rest` 操作还应该分两种状态，一种是 `buy` 之后的 `rest`（持有了股票），一种是 `sell` 之后的 `rest`（没有持有股票）。而且别忘了，我们还有交易次数 `k` 的限制，就是说你 `buy` 还只能在 `k > 0` 的前提下操作。

> [!NOTE]
> 这里提到的交易
> 一次买入和一次卖出定义为一次“交易”
> 


这个问题的状态有三个：
- 天数
- 允许交易的最大次数
- 当前的持有状态 （即之前说的rest状态， 1表示持有，0表示没有持有）。
一个三维数组就能装下这几种状态的全部组合
比如说 `dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 `dp[2][3][0]` 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。

而我们想求的最终答案是dp\[n-1]\[k]\[0],即最后一天，最多允许k次交易，最多获得多少利润。
为什么不是 `dp[n - 1][K][1]`？因为 `dp[n - 1][K][1]` 代表到最后一天手上还持有股票，`dp[n - 1][K][0]` 表示最后一天手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

记住如何解释「状态」，一旦觉得哪里不好理解，把它翻译成自然语言就容易理解了。

### 二、状态转移框架
开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。
只看「持有状态」，可以画个状态转移图：
![](https://labuladong.online/algo/images/stock/1.png)


状态转移方程：

```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max( 今天选择 rest,        今天选择 sell       )
```

解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：

1、我昨天就没有持有，且截至昨天最大交易次数限制为 `k`；然后我今天选择 `rest`，所以我今天还是没有持有，最大交易次数限制依然为 `k`。

2、我昨天持有股票，且截至昨天最大交易次数限制为 `k`；但是今天我 `sell` 了，所以我今天没有持有股票了，最大交易次数限制依然为 `k`。

```java
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max( 今天选择 rest,         今天选择 buy         )
```

解释：今天我持有着股票，最大交易次数限制为 `k`，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：

1、我昨天就持有着股票，且截至昨天最大交易次数限制为 `k`；然后今天选择 `rest`，所以我今天还持有着股票，最大交易次数限制依然为 `k`。

2、我昨天本没有持有，且截至昨天最大交易次数限制为 `k - 1`；但今天我选择 `buy`，所以今天我就持有股票了，最大交易次数限制为 `k`。

> [!NOTE]
> 我对这里的k一开始有疑问，我想知道为什么卖的时候k没有发生变化，而买的时候k就加一了。
> 要知道这里的交易指的是一次买和一次卖
> 一开始是没有股票的，所以买是交易的开始，当买了的时候，就证明这次交易开始了交易次数改增加了，而卖的时候，因为买的时候已经把这次交易的次数添加上了，所以卖的时候，交易的次数不变。
> 


base case



### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

**输入：**[7,1,5,3,6,4]
**输出：**5
**解释：**在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**示例 2：**

**输入：**prices = [7,6,4,3,1]
**输出：**0
**解释：**在这种情况下, 没有交易完成, 所以最大利润为 0。

---
这道题相对的代码思路利用上面的那套构思来想的话，相对比较简单，但是我写完代码后测试结果却不完全正确。
这是我的错误代码
```java
public int maxProfit(int[] prices) {  
 int [][] dp= new int [prices.length][2];  
 dp[0][0] = 0;  
 dp[0][1] = Integer.MIN_VALUE;  
 for(int i=1;i<prices.length;i++){  
     dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);  
   //-----------------------------------------------------
    dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);  
   //------------------------------------------------------
 }  
 return dp[prices.length-1][0];  
  
  
}
```
错误就在于我用注释框起来的那一句
dp\[i-1]\[0] 代表 **前 i-1 天的最大利润**，但是**这里的交易次数限制为 1**，所以 dp\[i-1]\[0] 不能被拿来计算买入的情况（因为你只能买一次）。
• dp\[i-1]\[0] 可能是一个非零值，导致 dp\[i-1]\[0] - prices\[i] 可能会错误地影响 dp\[i]\[1]，从而影响最终答案。
用我自己的话说就是，这个交易只能进行一次，如果你现在买入的话，就证明之前是没有进行交易的，所以之前的利润一定为0，所以这里不能用`dp[i-1][0]-prices[i]`应该直接把利润设置为0

正确代码：
```java
public int maxProfit(int[] prices) {

int [][] dp= new int [prices.length][2];

dp[0][0] = 0;

dp[0][1] = -prices[0];

for(int i=1;i<prices.length;i++){

dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);

dp[i][1]=Math.max(dp[i-1][1],-prices[i]);

}

return dp[prices.length-1][0];


}

```

### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 _你能获得的 **最大** 利润_ 。

**示例 1：**

**输入：**prices = [7,1,5,3,6,4]
**输出：**7
**解释：**在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。

**示例 2：**

**输入：**prices = [1,2,3,4,5]
**输出：**4
**解释：**在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。

**示例 3：**

**输入：**prices = [7,6,4,3,1]
**输出：**0
**解释：**在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。

---
这道题与上一道题类似，唯一的不同是上一道题限制了交易次数只能为1，而这道题不限制次数。
故所以 买入的时候 dp\[i-1]\[0]不再只可能为0，可以不用再写为0。
正确代码：
```java
public int maxProfit(int[] prices) {

int [][] dp= new int [prices.length][2];

dp[0][0] = 0;

dp[0][1] = - prices[0];//注意这里，第一天如果拥有股票的话，利润就为价格的负

for(int i=1;i<prices.length;i++){

dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);

dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);

}

return dp[prices.length-1][0];

  

}
```

### [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
给定一个整数数组`prices`，其中第  `prices[i]` 表示第 `i` 天的股票价格 。​
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

**输入:** prices = [1,2,3,0,2]
**输出:** 3 
**解释:** 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**示例 2:**

**输入:** prices = [1]
**输出:** 0

---
这道题与前面两道思路依旧相似，只不过这道题多了一个冷冻期，也就是买之前的前一天不能卖。
所以买的状态转移公式要改变一下：
`dp[i-2][0]-prices[i]` i-2不能为i-1，因为如果想买，前一天就不能卖，并且也不能连着买，所以利润在前一天就是没有变的，就得用前两天的利润再减去买股票的钱。
```java
public  int maxProfit3(int[] prices) {  
    int [][] dp= new int [prices.length][2];  
    dp[0][0] = 0;  
    dp[0][1] = -prices[0];  
  
    for(int i=1;i<prices.length;i++){  
             if(i-2 ==-1){  
                 dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);  
                 dp[i][1]=Math.max(dp[i-1][1],-prices[i]);  
  
             }else{  
                 dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);  
                 dp[i][1]=Math.max(dp[i-1][1],dp[i-2][0]-prices[i]);  
  
             }  
  
    }  
  
    return dp[prices.length-1][0];  
  
}
```

### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。
你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。
**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1：**

**输入：**prices = [1, 3, 2, 8, 4, 9], fee = 2
**输出：**8
**解释：**能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8

**示例 2：**

**输入：**prices = [1,3,7,5,10,3], fee = 3
**输出：**6

---
这道题没什么好解释的，思路还是完全一样，只不过把利润再减去手续费即可。

```java
public int maxProfit(int[] prices, int fee) {

int [][] dp= new int [prices.length][2];

dp[0][0] = 0;

dp[0][1] = -prices[0]-fee;

for(int i=1;i<prices.length;i++){

dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);

dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]-fee);

}

return dp[prices.length-1][0];

}
```


### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。
**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
**示例 1:**

**输入：**prices = [3,3,5,0,0,3,1,4]
**输出：**6
**解释：**在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

**示例 2：**

**输入：**prices = [1,2,3,4,5]
**输出：**4
**解释：**在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

**示例 3：**

**输入：**prices = [7,6,4,3,1] 
**输出：**0 
**解释：**在这个情况下, 没有交易完成, 所以最大利润为 0。

**示例 4：**

**输入：**prices = [1]
**输出：**0

---
这道题相较于前几道题，由二维的变成三维的了，多了一个记录交易次数的数组位置。
```Java
public int maxProfit(int[] prices) {

int [][][] dp= new int [prices.length][3][2];

for(int i=0;i<prices.length;i++){

for(int j=1;j<=2;j++){

if(i-1==-1){

dp[i][j][0]=0;

dp[i][j][1]=-prices[i];

continue;

}

dp[i][j][0]=Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);

dp[i][j][1]=Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i]);

  

}

}

return dp[prices.length-1][2][0];

}
```

### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**
**输入：**k = 2, prices = [2,4,1]
**输出：**2
**解释：**在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
**示例 2：**
**输入：**k = 2, prices = [3,2,6,5,0,3]
**输出：**7
**解释：**在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。


---
这道题和上一道题一模一样，只不过上一道题告诉了我们交易的准确次数是2，这道题是将交易的次数作为参数输入。

```java
public int maxProfit(int k, int[] prices) {

int [][][] dp= new int [prices.length][k+1][2];

for(int i=0;i<prices.length;i++){

for(int j=1;j<=k;j++){

if(i-1==-1){

dp[i][j][0]=0;

dp[i][j][1]=-prices[i];

continue;

}

dp[i][j][0]=Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);

dp[i][j][1]=Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i]);

  

}

}

return dp[prices.length-1][k][0];

}
```




